#!/usr/bin/env python3
"""
sample_ev.py
Author: Timothy Middlemas

Script to sample H_V(r) by binning nearest neighbors

Uses Scipy's cKDTree implementation for lookup

Implements periodic boundary conditions by 1 layer of
replication. Note that this is usually, but not always
correct, so be careful.

Usage: python3 sample_hv.py [n_samp] [cutoff] [n_bins] [infiles ...] > [outfile]

Will interpret multiple infiles as ensemble average

Options:
    --help -> Print this message
"""

import sys
import numpy as np
from scipy.spatial import cKDTree

if __name__ == "__main__":
    if "--help" in sys.argv:
        print(__doc__)
        sys.exit()

    n_samp = int(sys.argv[1])
    cutoff = float(sys.argv[2])
    n_bins = int(sys.argv[3])
    n_files = len(sys.argv[4:])

    step = cutoff/float(n_bins)
    check = np.linspace(0.0, cutoff, num=n_bins+1)
    check_upper = check[1:]
    check_lower = check[:-1]
    domain = check_upper - step/2.0
    hv = np.zeros(n_bins)

    for fname in sys.argv[4:]:
        # Read necessary stuff from file
        infile = open(fname)
        dim = int(infile.readline())
        basis = np.loadtxt(infile, max_rows=dim)[:, :dim]
        # https://stackoverflow.com/questions/31698242/python-how-can-i-force-1-element-numpy-arrays-to-be-two-dimensional
        points = np.atleast_2d(np.loadtxt(infile))[:, :dim]
        n_points = len(points)

        # Construct periodic images, tree, and samples
        periodic = np.tile(points, (3**dim, 1))
        for i in range(3**dim):
            for j in range(dim):
                a = i
                for k in range(j):
                    a = a//3
                a = (a%3) - 1
                periodic[i*n_points:(i+1)*n_points, :] += a*basis[j, :]
        
        tree = cKDTree(periodic)
        samples = np.random.rand(n_samp, dim) @ basis

        # Bin samples
        dd, ii = tree.query(samples, k=1, n_jobs=4)
        check_m_upper = np.tile(check_upper, (n_samp, 1))
        check_m_lower = np.tile(check_lower, (n_samp, 1))
        # https://stackoverflow.com/questions/17428621/python-differentiating-between-row-and-column-vectors
        bin_m_upper = np.less(dd[:, np.newaxis], check_m_upper, dtype=float)
        bin_m_lower = np.greater_equal(dd[:, np.newaxis], check_m_lower, dtype=float)
        hv += np.sum(bin_m_lower*bin_m_upper, axis=0)

    # Normalize
    hv /= float(n_samp*n_files)*step
    
    count = np.full(n_bins, float(n_samp*n_files))
    
    np.savetxt(sys.stdout.buffer, np.stack([domain, hv, count], -1))
