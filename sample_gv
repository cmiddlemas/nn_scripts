#!/usr/bin/env python3
"""
sample_gv.py
Author: Timothy Middlemas

Script to sample G_V(r) by binning nearest neighbors

Uses Scipy's cKDTree implementation for lookup

Implements periodic boundary conditions by 1 layer of
replication. Note that this is usually, but not always
correct, so be careful.

Usage: python3 sample_gv.py [n_samp] [cutoff] [n_bins] [infiles ...] > [outfile]

Will interpret multiple infiles as ensemble average

Options:
    --help -> Print this message
"""

import sys
import numpy as np
from scipy.spatial import cKDTree

if __name__ == "__main__":
    if "--help" in sys.argv:
        print(__doc__)
        sys.exit()

    n_samp = int(sys.argv[1])
    cutoff = float(sys.argv[2])
    n_bins = int(sys.argv[3])
    n_files = len(sys.argv[4:])

    step = cutoff/float(n_bins)
    check = np.linspace(0.0, cutoff, num=n_bins+1)
    check_upper = check[1:]
    check_lower = check[:-1]
    domain = check_upper - step/2.0
    gv = np.zeros(n_bins)
    count = np.zeros(n_bins)

    dim = 0
    for m, fname in enumerate(sys.argv[4:]):
        if m%100 == 0:
            # https://stackoverflow.com/questions/5574702/how-to-print-to-stderr-in-python
            print("Working on file " + str(m), file=sys.stderr)
        # Read necessary stuff from file
        infile = open(fname)
        dim = int(infile.readline())
        basis = np.loadtxt(infile, max_rows=dim)[:, :dim]
        # https://stackoverflow.com/questions/31698242/python-how-can-i-force-1-element-numpy-arrays-to-be-two-dimensional
        points = np.atleast_2d(np.loadtxt(infile))[:, :dim]
        n_points = len(points)

        # Construct periodic images, tree, and samples
        periodic = np.tile(points, (3**dim, 1))
        for i in range(3**dim):
            for j in range(dim):
                a = i
                for k in range(j):
                    a = a//3
                a = (a%3) - 1
                periodic[i*n_points:(i+1)*n_points, :] += a*basis[j, :]
        
        tree = cKDTree(periodic)
        samples = np.random.rand(n_samp, dim) @ basis

        # Bin samples
        dd, ii = tree.query(samples, k=1, n_jobs=-1)
        check_m_upper = np.tile(check_upper, (n_samp, 1))
        check_m_lower = np.tile(check_lower, (n_samp, 1))
        # https://stackoverflow.com/questions/17428621/python-differentiating-between-row-and-column-vectors
        bin_m_upper = np.less(dd[:, np.newaxis], check_m_upper, dtype=float)
        bin_m_lower = np.greater_equal(dd[:, np.newaxis], check_m_lower, dtype=float)
        gv += np.sum(bin_m_upper*bin_m_lower, axis=0)
        count += np.sum(bin_m_lower, axis=0)

    # Normalize
    gv /= count
    gv /= step
    if dim == 3:
        gv /= 4.0*np.pi*domain*domain
    elif dim == 2:
        gv /= 2.0*np.pi*domain
    else:
        print("That dimension isn't implemented, printing rho s_1 G_V instead of rho G_V")

    np.savetxt(sys.stdout.buffer, np.stack([domain, gv, count], -1))
